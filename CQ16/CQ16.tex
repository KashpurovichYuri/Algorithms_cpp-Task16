\documentclass[a4paper,12pt]{article}	% тип документа

\usepackage[a4paper,top=1.3cm,bottom=2cm,left=1.5cm,right=1.5cm,marginparwidth=0.75cm]{geometry} % field settings

\usepackage[T2A]{fontenc}		% кодировка
\usepackage[utf8]{inputenc}		% кодировка исходного текста
\usepackage[english,russian]{babel}	% локализация и переносы
\usepackage{indentfirst}

%Piece of code
\usepackage{listings}
\usepackage{xcolor}
\lstset
{
    language=C++,
    backgroundcolor=\color{black!4}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

%Drawings
\usepackage{graphicx}

\usepackage{wrapfig}

\usepackage{multirow}

\usepackage{float}

\usepackage{wasysym}

\usepackage[T1]{fontenc}
\usepackage{titlesec}

\setlength{\parindent}{3ex}

%Quatation
\usepackage{csquotes}

% Literature
\addto\captionsrussian{\def\refname{Литература.}}

%Header
\title{
	\center{\textbf{Контрольные вопросы. Задание 16.}}
	}


\begin{document}	% the beginning of the document

\maketitle

\section{Как организован механизм генерации случайных чисел в библиотеке random?}

	Библиотека random включает две основные сущности: uniform random bit generators (URBGs -- равномерные генераторы случайных битов) и random number distributions (генераторы случайных чисел). Первая из них включает в себя механизмы случайных чисел, которые представляют собой генераторы псевдослучайных чисел, генерирующие целочисленные последовательности с равномерным распределением, а также генераторы истинных случайных чисел, если они доступны. Вторая сущность преобразуют выходные данные первой в различные статистические распределения.
	
	Более подробно, URBG -- это функциональный объект, возвращающий целочисленные значения без знака таким образом, что каждое значение в диапазоне возможных результатов имеет (в идеале) одинаковую вероятность возврата. Генераторы унифицированных случайных битов не предназначены для использования в качестве генераторов случайных чисел: они используются в качестве источника случайных битов (генерируются массово, для эффективности). Любой равномерный генератор случайных битов может быть подключен к любому распределению случайных чисел, чтобы получить случайное число (формально, случайную переменную). Все URBG соответствуют требованиям UniformRandomBitGenerator.
	
	Механизмы генерации случайных чисел (random number engines) генерируют псевдослучайные числа, используя начальные данные в качестве источника энтропии. Выбор механизма для использования включает в себя ряд компромиссов: линейный конгруэнтный движок (linear\_congruential\_engine) умеренно быстр и требует очень мало памяти для состояния. Генераторы Фибоначчи с запаздыванием (subtract\_with\_carry\_engine) работают очень быстро даже на процессорах без расширенных наборов арифметических инструкций за счет большей памяти состояния и иногда менее желательных спектральных характеристик. Вихрь Мерсенна (mersenne\_twister\_engine) медленнее и требует большего хранения состояния, но при правильных параметрах имеет самую длинную неповторяющуюся последовательность с наиболее желательными спектральными характеристиками (для данного определения желаемого). Несколько популярных алгоритмов генерации предопределены. Кроме того, можно использовать адаптеры механизмов случайных чисел, генерирующие псевдослучайные числа, используя другой механизм случайных чисел в качестве источника энтропии.
	
	Зачастую, используемые начальные данные делают процесс генерации случайных чисел детерминированным (что нарушает случайность), поэтому существует недетерминированный универсальный генератор случайных битов std::random\_device. Правда, разрешено реализовывать std::random\_device с использованием механизма псевдослучайных чисел, если не поддерживается генерация недетерминированных случайных чисел.
	
	Наконец, распределения случайных чисел, удовлетворяющие требованиям RandomNumberDistribution, выполняют постобработку выходных данных URBG таким образом, что итоговые данные распределяются в соответствии с определенной статистической функцией плотности вероятности.
	
	Типичная схема генерации выглядит следующим образом. Сначала используется std::random\_device, который генерирует зерно (seed). Затем одному из движков генерации случайных чисел передаётся это зерно, и полученный генератор далее может быть использован для получения чисел с некоторым распределением.
	
\section{Чем отличаются функциональные объекты от функций и лямбда-выражений?}		
	Функциональные объекты, или функторы, -- это классы с переопределённым оператором operator().  Поэтому их синтаксис напоминает таковой у функций, но последние не являются классами, чем и обусловлены отличия:
	
	\begin{itemize}
	
		\item Можно создавать различные экземпляры функциональных объектов, т.к. функторы -- это классы. Причём каждый класс имеет свой тип в то время, как у функций тип Return\_Type (Types...). 	
	
		\item Функциональный объект может иметь состояние (благодаря данным-членам), у функции же можно использовать static переменную, но этого делать не рекомендуется
		
		\item Функциональные объекты работают быстрее функций, переданных через указатель. Собственно говоря, из-за возможности компилятора оптимизировать код часто функторы или лямбда-функции оказывается использовать лучше, чем указатели на функции (например, при передаче функтора в функцию), т.к. указатели используют память более сложным образом.
	
	\end{itemize}
	
	Лямбда-выражения, являющиеся локальными функцими, которые можно создавать прямо внутри какого-либо выражения, сочетают в себе преимущества указателей на функции и функциональных объектов, благодаря чему их удобно создавать и использовать на месте (в том числе используя захват). Как и функциональные объекты, лямбда-выражения позволяют хранить состояния, но их компактный синтаксис в отличие от функциональных объектов не требует объявления класса.
	
\section{Какими наборами возможностей обладают итераторы различных категорий?}

	Все категории итераторов могут быть инкрементированы на единицу, а также поддерживают инициализацию копированием.
	
	Рассмотрим более подробно возможности итераторов различных категорий:
	
	\begin{itemize}

		\item Input iterator поддерживает сравнение на равенство/неравенство (использование operator==, operator!=)	и может быть разыменован только как rvalue (т.е. только для получения значения, т.к. связан с потоком ввода данных).
		
		\item Output iterator может быть разыменован как lvalue для использования слева от знака присваивания.
		
		\item Forward iterator обладает теми же возможножностями что Input и Output iterators, а также может быть скопирован и использован для повторного обхода.
		
		\item Bidirectional iterator обладает теми же возможножностями что Input, Output и Forward iterators, а также может быть уменьшен на единицу.
		
		\item Random access iterator поддерживает:
		
		\begin{itemize}
		
			\item все возможности итераторов остальных категорий;
			
			\item арифметические операции + и - (арифметика указателей);
			
			\item сравнения между указателями (operator>, operator<, operator>=, operator<=);
			
			\item операции увеличения и уменьшения на (operator+=, operator-=);
			
			\item разыменование по индексу ([]).
		
		\end{itemize}	
	
	\end{itemize} 
	
	Существуют также insert iterators/inserters, позволяющие алгоритмам стандартной библиотеки работать со вставками в начало/конец.

\section{Какая классификация предлагается для алгоритмов стандартной библиотеки?}

	Классификация алгоритмов стандартной библиотеки:
	
	\begin{itemize}
	
		\item немодифицирующие;
		
		\item модифицирующие;
		
		\item удаления;
		
		\item перестановки;
		
		\item сортировки;
		
		\item для упорядочивания диапазонов;
		
		\item численные.
	
	\end{itemize}
	
	Один из важнейших алгоритмов std::for\_each относится к двум классам алгоритмов STL: он является и модифицирующим, и немодифицирующим.

\section{Почему алгоритмы стандартной библиотеки предпочтительнее собственных?}
	
	Алгоритмы стандартной библиотеки предпочтительнее собственных, поскольку не будет необходимости писать собственный код, который будет выглядеть более громоздко, т.е. использование алгоритмов стандартной библиотеки проще, короче и быстрее.	
		
\newpage


\addcontentsline{toc}{section}{Литература}
 
	\begin{thebibliography}{}
	
		\bibitem{litlink1} Конспект семинара. Макаров И.С.
		\bibitem{litlink2} https://en.cppreference.com/w/cpp/numeric/random
		
	\end{thebibliography}


\end{document} % end of the document
